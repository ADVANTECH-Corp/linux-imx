/*
 *  Copyright 2012-2020 NXP
 *
 *  NXP CONFIDENTIAL
 *  The source code contained or described herein and all documents related to
 *  the source code ("Material") are owned by NXP or its
 *  suppliers or licensors. Title to the Material remains with NXP
 *  or its suppliers and licensors. The Material contains trade secrets and
 *  proprietary and confidential information of NXP or its suppliers and
 *  licensors. The Material is protected by worldwide copyright and trade secret
 *  laws and treaty provisions. No part of the Material may be used, copied,
 *  reproduced, modified, published, uploaded, posted, transmitted, distributed,
 *  or disclosed in any way without NXP's prior express written permission.
 *
 *  No license under any patent, copyright, trade secret or other intellectual
 *  property right is granted to or conferred upon you by disclosure or delivery
 *  of the Materials, either expressly, by implication, inducement, estoppel or
 *  otherwise. Any license under such intellectual property rights must be
 *  express and approved by NXP in writing.
 *
 */
/* module.h: common structures and definitions used by all modules
 */
#ifndef __MODULE_H__
#define __MODULE_H__

#include "mwu_defs.h"
#include "queue.h" /* SLIST_* macros */
/* module_config_method: config methods used with wifi direct
 */
enum module_config_method {
	MODULE_CONFIG_METHOD_NONE = 0,
	MODULE_CONFIG_METHOD_DISPLAY = 0x0008,
	MODULE_CONFIG_METHOD_DISPLAY_VIRT = 0x2008,
	MODULE_CONFIG_METHOD_DISPLAY_PHYS = 0x4008,
	MODULE_CONFIG_METHOD_EXT_NFC = 0x0010,
	MODULE_CONFIG_METHOD_INT_NFC = 0x0020,
	MODULE_CONFIG_METHOD_NFC_INTF = 0x0040,
	MODULE_CONFIG_METHOD_PBC = 0x0080,
	MODULE_CONFIG_METHOD_PBC_VIRT = 0x0280,
	MODULE_CONFIG_METHOD_PBC_PHYS = 0x0480,
	MODULE_CONFIG_METHOD_KEYPAD = 0x0100,
};

/* struct event: generic event emitted by a module
 *
 * Modules emit events via callbacks that are registered when the module is
 * initialized.  The events are passed as a struct event.  The type of the
 * event and the meaning of the status is module-dependent.  val is a
 * variable-length payload whose contents depend on the event.  len is the
 * length of the variable-length payload.
 *
 * iface is the new member of the struct. It is used to let the caller know
 * about the interface event is arrieved from.
 */
struct event {
	int type;
	int status;
	int len;
	char iface[IFNAMSIZ + 1];
	char val[0];
};

/* event_cb: event callback for events generated by modules
 *
 * When a module is initialized, the caller should provide a callback that will
 * handle events emitted by the module.  This callback will be invoked when
 * events occur.  The structure of the events are described above.  The meaning
 * of the events are module-specific and are described in the module
 * documentation.
 */
typedef void (*event_cb)(struct event *event, void *priv);

/* struct module: a module running on a particular interface
 *
 * This is a generic struct that represents a module.  It is typically
 * initialized by a caller who wishes to run an instance of a particular module
 * on a particular interface.
 *
 * iface: the interface on which this module instance is running.
 *
 * module_id: Module identifier
 *
 * cb: event callback for this instance.  This callback is called when the
 * module generates events.  The events are module-dependent and are described
 * in the module-specific documentation.
 *
 * cbpriv: arbitrary data passed as the priv argument to cb when it is invoked
 * with an event.
 *
 * modpriv: arbitrary data for use by the module.  Note that this member is
 * generally initialized by a modules init routine, not by the caller who calls
 * that routine.
 */
struct module {
	char iface[IFNAMSIZ + 1];
	int module_id;
	event_cb cb;
	void *cbpriv;
	void *modpriv;

	/*internal*/
	SLIST_ENTRY(module) list_item;
};

/* convenience macro to invoke the callback with an event */
#define MODULE_DO_CALLBACK(mod, event)                                         \
	do {                                                                   \
		if (mod && mod->cb) {                                          \
			mod->cb(event, mod->cbpriv);                           \
		}                                                              \
	} while (0)

#endif
