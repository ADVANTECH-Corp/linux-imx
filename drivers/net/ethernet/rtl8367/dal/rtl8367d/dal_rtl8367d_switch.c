/*
 * Copyright (C) 2012 Realtek Semiconductor Corp.
 * All Rights Reserved.
 *
 * This program is the proprietary software of Realtek Semiconductor
 * Corporation and/or its licensors, and only be used, duplicated,
 * modified or distributed under the authorized license from Realtek.
 *
 * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
 * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
 *
 * Purpose : Definition of Switch Global API
 *
 * Feature : The file have include the following module and sub-modules
 *           (1) Switch parameter settings
 *
 */


/*
 * Include Files
 */
#include <dal/rtl8367d/dal_rtl8367d_switch.h>
#include <dal/rtl8367d/dal_rtl8367d_rate.h>
#include <dal/rtl8367d/dal_rtl8367d_port.h>
#include <dal/rtl8367d/rtl8367d_asicdrv.h>

/*
 * Symbol Definition
 */

/*
 * Data Declaration
 */
#define NCTRL_INIT_SIZE 1545
rtk_uint8 NCtrl_init[NCTRL_INIT_SIZE] = {
0x02,0x04,0x32,0xE4,0xF5,0xA8,
0xD2,0xAF,0x22,0x22,0x22,0x02,0x05,0x66,
0x90,0x06,0x2A,0xEE,0xF0,0xA3,0xEF,0xF0,
0x4E,0x70,0x05,0xFE,0x7F,0x0D,0x80,0x04,
0x7E,0x00,0x7F,0x0F,0x90,0x06,0x2E,0xEE,
0xF0,0xA3,0xEF,0xF0,0x90,0x06,0x2A,0xE0,
0x70,0x02,0xA3,0xE0,0x70,0x04,0x7F,0x11,
0x80,0x02,0x7F,0x78,0x7E,0x1D,0x12,0x01,
0x88,0x90,0x06,0x2D,0xE0,0x54,0x1F,0x64,
0x1F,0x60,0x76,0x12,0x01,0x33,0x20,0xE4,
0x70,0x7F,0xF4,0x7E,0x01,0x12,0x05,0xB5,
0x12,0x01,0x33,0x20,0xE4,0x63,0x12,0x05,
0x03,0x12,0x01,0x88,0x90,0x06,0x2C,0x12,
0x04,0xED,0x7E,0x00,0x90,0x06,0x2D,0xE0,
0x12,0x04,0xE2,0xAD,0x07,0x12,0x05,0x03,
0x12,0x01,0x04,0x44,0x20,0x12,0x01,0x5F,
0x7D,0x3F,0x7C,0x00,0x12,0x00,0xC0,0x44,
0x04,0x12,0x01,0x5F,0x7D,0x00,0x7C,0x04,
0x12,0x00,0xC0,0x54,0xFB,0x12,0x04,0xE2,
0xFD,0x7F,0x02,0x7E,0x66,0x12,0x05,0xD5,
0x7D,0x00,0x7C,0x04,0x12,0x01,0x72,0x12,
0x01,0x04,0x54,0xDF,0x12,0x04,0xE2,0xFD,
0x7F,0x02,0x7E,0x66,0x12,0x05,0xD5,0x7D,
0x3F,0x7C,0x00,0x12,0x01,0x72,0x12,0x05,
0xD5,0x22,0x7F,0x01,0x7E,0x66,0x12,0x05,
0xD5,0x90,0x06,0x2E,0xE0,0xFC,0xA3,0xE0,
0x44,0xC0,0xFD,0x7F,0x00,0x7E,0x66,0x12,
0x05,0xD5,0x7D,0x00,0x7C,0x04,0x7F,0x01,
0x7E,0x66,0x12,0x05,0xD5,0x90,0x06,0x2E,
0xE0,0xFC,0xA3,0xE0,0x44,0x80,0xFD,0x7F,
0x00,0x7E,0x66,0x12,0x05,0xD5,0x7F,0x02,
0x7E,0x66,0x12,0x05,0x91,0x90,0x06,0x2C,
0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0x12,0x05,
0xD5,0x7D,0x3F,0x7C,0x00,0x7F,0x01,0x7E,
0x66,0x12,0x05,0xD5,0x90,0x06,0x2E,0xE0,
0xFC,0xA3,0xE0,0x44,0x80,0xFD,0x7F,0x00,
0x7E,0x66,0x12,0x05,0xD5,0x7F,0x02,0x7E,
0x66,0x12,0x05,0x91,0x90,0x06,0x2C,0xEE,
0xF0,0xA3,0xEF,0xF0,0x22,0x7D,0x3D,0x7C,
0x00,0x7F,0x01,0x7E,0x66,0x12,0x05,0xD5,
0x90,0x06,0x2E,0xE0,0xFC,0xA3,0xE0,0x44,
0x80,0xFD,0x7F,0x00,0x7E,0x66,0x12,0x05,
0xD5,0x7F,0x02,0x7E,0x66,0x12,0x05,0x91,
0x90,0x06,0x2C,0xEE,0xF0,0xA3,0xEF,0xF0,
0x22,0xFF,0x90,0x06,0x2C,0xEE,0xF0,0xFC,
0xA3,0xEF,0xF0,0xFD,0x7F,0x02,0x7E,0x66,
0x12,0x05,0xD5,0x22,0x7F,0x01,0x7E,0x66,
0x12,0x05,0xD5,0x90,0x06,0x2E,0xE0,0xFC,
0xA3,0xE0,0x44,0xC0,0xFD,0x7F,0x00,0x7E,
0x66,0x22,0x12,0x05,0x91,0x90,0x06,0x2C,
0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0xC5,0xF0,
0xF8,0xA3,0xE0,0x28,0xF0,0xC5,0xF0,0xF8,
0xE5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,
0xE0,0x38,0xF0,0x22,0x75,0xF0,0x08,0x75,
0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
0xF9,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xE8,0x9C,
0x45,0xF0,0x22,0xE0,0xFC,0xA3,0xE0,0xFD,
0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x22,0xE0,
0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
0xE0,0xFB,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0xE4,
0x90,0x06,0x30,0xF0,0xA3,0xF0,0x90,0x06,
0x30,0xE0,0xFE,0xA3,0xE0,0xFF,0xD3,0x94,
0x04,0xEE,0x94,0x00,0x40,0x03,0x02,0x03,
0x5F,0xEF,0x24,0xD0,0xFF,0xEE,0x34,0x12,
0xFE,0x12,0x03,0x72,0x7E,0x00,0x30,0xE6,
0x04,0x7F,0x01,0x80,0x02,0x7F,0x00,0x90,
0x06,0x2C,0xEE,0xF0,0xA3,0xEF,0xF0,0x90,
0x06,0x2B,0xE0,0x7E,0x00,0x30,0xE2,0x04,
0x7F,0x01,0x80,0x02,0x7F,0x00,0x90,0x06,
0x2E,0xEE,0xF0,0xA3,0xEF,0xF0,0x90,0x06,
0x2C,0xE0,0x70,0x02,0xA3,0xE0,0x70,0x1A,
0x90,0x06,0x2E,0xE0,0x70,0x02,0xA3,0xE0,
0x70,0x10,0x12,0x04,0xF4,0x7D,0x60,0x7C,
0x00,0x12,0x03,0x60,0x7D,0x60,0x7C,0x00,
0x80,0x33,0x90,0x06,0x2C,0xE0,0x70,0x04,
0xA3,0xE0,0x64,0x01,0x70,0x2A,0x90,0x06,
0x2E,0xE0,0x70,0x04,0xA3,0xE0,0x64,0x01,
0x70,0x1E,0x90,0x06,0x31,0xE0,0x24,0xC8,
0x12,0x04,0xFA,0x12,0x03,0x72,0x4E,0x60,
0x0F,0x12,0x04,0xF4,0xE4,0xFD,0xFC,0x12,
0x03,0x60,0xE4,0xFD,0xFC,0x12,0x05,0xD5,
0x90,0x06,0x30,0x12,0x04,0xED,0x02,0x02,
0xB4,0x22,0x12,0x05,0xD5,0x90,0x06,0x31,
0xE0,0x24,0xC8,0xFF,0x90,0x06,0x30,0xE0,
0x34,0x12,0xFE,0x22,0x12,0x05,0x91,0x90,
0x06,0x2A,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,
0x7D,0x40,0x12,0x04,0x28,0xE4,0xFF,0xFE,
0xFD,0x80,0x0C,0x7F,0x20,0x7E,0x4E,0x12,
0x04,0xD5,0x50,0x08,0x12,0x04,0xBE,0x12,
0x05,0x12,0x80,0xEF,0xE4,0xF5,0xA8,0xD2,
0xAF,0x12,0x05,0x2E,0x12,0x05,0xFC,0xE4,
0xFF,0xFE,0xFD,0x80,0x08,0x12,0x04,0xD1,
0x50,0x08,0x12,0x04,0xBE,0x12,0x05,0x12,
0x80,0xF3,0x7D,0x41,0x12,0x04,0x28,0xE4,
0xFF,0xFE,0xFD,0x80,0x08,0x12,0x04,0xD1,
0x50,0x08,0x12,0x04,0xBE,0x12,0x05,0x12,
0x80,0xF3,0xD2,0xA9,0xD2,0x8C,0x7D,0xF8,
0x7C,0x00,0x7F,0x4A,0x7E,0x13,0x12,0x05,
0xD5,0x12,0x00,0x0A,0x12,0x02,0xAD,0xE4,
0xFF,0xFE,0x12,0x00,0x0E,0x12,0x02,0xAD,
0x7F,0x01,0x7E,0x00,0x12,0x00,0x0E,0x7F,
0xA0,0x7E,0x13,0x12,0x05,0x91,0x90,0x06,
0x28,0xEE,0xF0,0xA3,0xEF,0xF0,0x90,0x06,
0x28,0x12,0x04,0xED,0x7E,0x00,0x90,0x06,
0x29,0xE0,0x90,0x06,0x28,0x12,0x04,0xE5,
0xAD,0x07,0x7F,0xA0,0x7E,0x13,0x12,0x05,
0xD5,0x7F,0xF4,0x7E,0x01,0x12,0x05,0xB5,
0x80,0xBA,0x7C,0x00,0x7F,0x36,0x7E,0x13,
0x12,0x05,0xD5,0x22,0x78,0x7F,0xE4,0xF6,
0xD8,0xFD,0x75,0x81,0x34,0x02,0x04,0x79,
0x02,0x03,0x7E,0xE4,0x93,0xA3,0xF8,0xE4,
0x93,0xA3,0x40,0x03,0xF6,0x80,0x01,0xF2,
0x08,0xDF,0xF4,0x80,0x29,0xE4,0x93,0xA3,
0xF8,0x54,0x07,0x24,0x0C,0xC8,0xC3,0x33,
0xC4,0x54,0x0F,0x44,0x20,0xC8,0x83,0x40,
0x04,0xF4,0x56,0x80,0x01,0x46,0xF6,0xDF,
0xE4,0x80,0x0B,0x01,0x02,0x04,0x08,0x10,
0x20,0x40,0x80,0x90,0x05,0xF1,0xE4,0x7E,
0x01,0x93,0x60,0xBC,0xA3,0xFF,0x54,0x3F,
0x30,0xE5,0x09,0x54,0x1F,0xFE,0xE4,0x93,
0xA3,0x60,0x01,0x0E,0xCF,0x54,0xC0,0x25,
0xE0,0x60,0xA8,0x40,0xB8,0xE4,0x93,0xA3,
0xFA,0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,
0xC8,0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,
0xF0,0xA3,0xC8,0xC5,0x82,0xC8,0xCA,0xC5,
0x83,0xCA,0xDF,0xE9,0xDE,0xE7,0x80,0xBE,
0x90,0x06,0x24,0x12,0x02,0x89,0xEF,0x24,
0x01,0xFF,0xE4,0x3E,0xFE,0xE4,0x3D,0xFD,
0xE4,0x3C,0x22,0x7F,0xD0,0x7E,0x07,0xE4,
0xFD,0xFC,0x90,0x06,0x24,0x12,0x02,0x95,
0xC3,0x02,0x02,0x78,0x90,0x06,0x2C,0xFF,
0xEE,0xF0,0xFC,0xA3,0xEF,0xF0,0x22,0xE4,
0x75,0xF0,0x01,0x02,0x01,0x94,0x90,0x06,
0x31,0xE0,0x24,0xC0,0xFF,0x90,0x06,0x30,
0xE0,0x34,0x12,0xFE,0x22,0x90,0x06,0x2B,
0xE0,0x24,0xA1,0xFF,0x90,0x06,0x2A,0xE0,
0x34,0x13,0xFE,0x22,0xFC,0x90,0x06,0x24,
0x02,0x02,0xA1,0x78,0x33,0xE6,0xF5,0x8C,
0x78,0x34,0xE6,0xF5,0x8A,0x22,0x78,0x33,
0xF6,0xAF,0x05,0xEF,0x78,0x34,0xF6,0x22,
0x75,0x89,0x11,0xE4,0x7B,0xA0,0x7A,0x05,
0xF9,0xF8,0xAF,0x0B,0xAE,0x0A,0xAD,0x09,
0xAC,0x08,0x12,0x01,0xE6,0xAD,0x07,0xAC,
0x06,0xC3,0xE4,0x9D,0xFD,0xE4,0x9C,0xFC,
0x12,0x05,0x24,0x12,0x05,0x19,0x74,0x0D,
0x2D,0xFD,0xE4,0x3C,0x12,0x05,0x24,0x75,
0x88,0x10,0x53,0x8E,0xC7,0xD2,0xA9,0x22,
0xC0,0xE0,0xC0,0xF0,0xC0,0x83,0xC0,0x82,
0xC0,0xD0,0x75,0xD0,0x00,0xC0,0x00,0x12,
0x05,0x19,0x90,0x06,0x32,0x12,0x04,0xED,
0x90,0x06,0x34,0x12,0x04,0xED,0xD0,0x00,
0xD0,0xD0,0xD0,0x82,0xD0,0x83,0xD0,0xF0,
0xD0,0xE0,0x32,0xC2,0xAF,0xAD,0x07,0xAC,
0x06,0x8C,0xA2,0x8D,0xA3,0x75,0xA0,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xAE,0xA1,0xBE,0x00,0xF0,
0xAE,0xA6,0xAF,0xA7,0xD2,0xAF,0x22,0xE4,
0xFD,0xFC,0xC3,0xED,0x9F,0xEC,0x9E,0x50,
0x15,0xE4,0xFB,0xFA,0x0B,0xBB,0x00,0x01,
0x0A,0xBA,0x04,0xF8,0xBB,0x6F,0xF5,0x0D,
0xBD,0x00,0x01,0x0C,0x80,0xE4,0x22,0xC2,
0xAF,0xAB,0x07,0xAA,0x06,0x8A,0xA2,0x8B,
0xA3,0x8C,0xA4,0x8D,0xA5,0x75,0xA0,0x03,
0x00,0x00,0x00,0xAA,0xA1,0xBA,0x00,0xF8,
0xD2,0xAF,0x22,0x42,0x06,0x34,0x00,0x00,
0x42,0x06,0x32,0x00,0x00,0x00,0x12,0x00,
0x09,0x12,0x06,0x05,0x02,0x00,0x03,0xE4,
0xF5,0x8E,0x22};
/*
 * Function Declaration
 */
static rtk_api_ret_t _dal_rtl8367d_switch_portMaxPktLen_set(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 cfgId)
{
    rtk_api_ret_t retVal;

    /* Check initialization state */
    RTK_CHK_INIT_STATE();

    /* Check Port Valid */
    RTK_CHK_PORT_VALID(port);

    if(speed >= MAXPKTLEN_LINK_SPEED_END)
        return RT_ERR_INPUT;

    if(cfgId > MAXPKTLEN_CFG_ID_MAX)
        return RT_ERR_INPUT;

    if((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_MAX_LENGTH_CFG, (speed * 8) + rtk_switch_port_L2P_get(port), cfgId)) != RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static rtk_api_ret_t _dal_rtl8367d_switch_portMaxPktLen_get(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 *pCfgId)
{
    rtk_api_ret_t retVal;

    /* Check initialization state */
    RTK_CHK_INIT_STATE();

    /* Check Port Valid */
    RTK_CHK_PORT_VALID(port);

    if(speed >= MAXPKTLEN_LINK_SPEED_END)
        return RT_ERR_INPUT;

    if(NULL == pCfgId)
        return RT_ERR_NULL_POINTER;

    if((retVal = rtl8367d_getAsicRegBit(RTL8367D_REG_MAX_LENGTH_CFG, (speed * 8) + rtk_switch_port_L2P_get(port), pCfgId)) != RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static rtk_api_ret_t _dal_rtl8367d_switch_maxPktLenCfg_set(rtk_uint32 cfgId, rtk_uint32 pktLen)
{
    rtk_api_ret_t retVal;

    /* Check initialization state */
    RTK_CHK_INIT_STATE();

    if(cfgId > MAXPKTLEN_CFG_ID_MAX)
        return RT_ERR_INPUT;

    if(pktLen > RTK_SWITCH_MAX_PKTLEN)
        return RT_ERR_INPUT;

    if((retVal = rtl8367d_setAsicRegBits(RTL8367D_REG_MAX_LEN_RX_TX_CFG0 + cfgId, RTL8367D_MAX_LEN_RX_TX_CFG0_MASK, pktLen)) != RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static rtk_api_ret_t _dal_rtl8367d_switch_maxPktLenCfg_get(rtk_uint32 cfgId, rtk_uint32 *pPktLen)
{
    rtk_api_ret_t retVal;

    /* Check initialization state */
    RTK_CHK_INIT_STATE();

    if(cfgId > MAXPKTLEN_CFG_ID_MAX)
        return RT_ERR_INPUT;

    if(NULL == pPktLen)
        return RT_ERR_NULL_POINTER;

    if((retVal = rtl8367d_getAsicRegBits(RTL8367D_REG_MAX_LEN_RX_TX_CFG0 + cfgId, RTL8367D_MAX_LEN_RX_TX_CFG0_MASK, pPktLen)) != RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      dal_rtl8367d_switch_init
 * Description:
 *      Set chip to default configuration enviroment
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 * Note:
 *      The API can set chip registers to default configuration for different release chip model.
 */
rtk_api_ret_t dal_rtl8367d_switch_init(void)
{
    rtk_port_t port;
    rtk_api_ret_t retVal;
    rtk_uint32 idx;
    rtk_uint32 counter = 0;
    rtk_uint32 regData;
    rtk_uint32 patchData2[][2] = { 
    {0xa436, 0x8028}, {0xa438, 0x4201}, {0xa436, 0xB820}, {0xa438, 0x0090}, {0xa436, 0xA012}, {0xa438, 0x0000}, {0xa436, 0xA014}, {0xa438, 0x2C04},
    {0xa438, 0x2C06}, {0xa438, 0x2C14}, {0xa438, 0x2C16}, {0xa438, 0xc114}, {0xa438, 0x25a0}, {0xa438, 0x410e}, {0xa438, 0x157f}, {0xa438, 0x15c6},
    {0xa438, 0xd501}, {0xa438, 0xa103}, {0xa438, 0x8203}, {0xa438, 0xd500}, {0xa438, 0x206a}, {0xa438, 0x15cc}, {0xa438, 0xd501}, {0xa438, 0x8103},
    {0xa438, 0xa203}, {0xa438, 0xd500}, {0xa438, 0x206a}, {0xa438, 0xc2f3}, {0xa438, 0x209a}, {0xa436, 0xA004}, {0xa438, 0x0099}, {0xa436, 0xA002},
    {0xa438, 0x0065}, {0xa436, 0xA000}, {0xa438, 0x759f}, {0xa436, 0xb820}, {0xa438, 0x0000}};    
    
    if((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_IO_MISC_FUNC, RTL8367D_INT_EN_OFFSET, 1)) != RT_ERR_OK)
        return retVal;

    for(idx = 0; idx <= RTK_MAX_METER_ID; idx++)
    {
        if ((retVal = dal_rtl8367d_rate_shareMeter_set(idx, METER_TYPE_KBPS, RTL8367D_QOS_RATE_INPUT_MAX_HSG, DISABLED)) != RT_ERR_OK)
            return retVal;
    }

    switch (rtk_switch_chipType_get())
    {
        case CHIP_RTL8367D:
            RTK_SCAN_ALL_LOG_PORT(port)
            {
                if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
                {
                    if ((retVal = dal_rtl8367d_port_phyOCPReg_set(port, 0xb820, 0x0010)) != RT_ERR_OK)
                        return retVal;
                    
                    counter = 0;
                    do 
                    {
                        if ((retVal = dal_rtl8367d_port_phyOCPReg_get(port, 0xb800, &regData)) != RT_ERR_OK)
                            return retVal;

                        if ((regData & 0x40) != 0 )
                            break;
                        
                        counter++;
                    } while (counter < 200);   //Wait for patch ready = 1...

                    if ((regData & 0x40) == 0 )
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    for(idx = 0; idx < sizeof(patchData2) / (sizeof(rtk_uint32) * 2); idx++)
                    {
                        if((retVal = dal_rtl8367d_port_phyOCPReg_set(port, patchData2[idx][0], patchData2[idx][1])) != RT_ERR_OK)
                            return retVal;
                    }

                    if ((retVal = dal_rtl8367d_port_phyOCPReg_get(port, 0xa432, &regData)) != RT_ERR_OK)
                        return retVal;

                    regData = regData & 0xFFBF;
                    if ((retVal = dal_rtl8367d_port_phyOCPReg_set(port, 0xa432, regData)) != RT_ERR_OK)
                        return retVal;  
                }
            }

            /* Bypass PHY Ability Lock */
            if((retVal = rtl8367d_setAsicRegBits(RTL8367D_REG_BYPASS_ABLTY_LOCK, RTL8367D_BYPASS_PHY_MASK, 0x1F)) != RT_ERR_OK)
                return retVal;

            /* NCtrl */
            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_CHIP_RESET, RTL8367D_DW8051_RST_OFFSET, 1)) != RT_ERR_OK)
                return retVal;

            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_MISCELLANEOUS_CONFIGURE0, RTL8367D_DW8051_EN_OFFSET, 1)) != RT_ERR_OK)
                return retVal;

            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_DW8051_RDY, RTL8367D_ACS_IROM_ENABLE_OFFSET, 1)) != RT_ERR_OK)
                return retVal;

            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_DW8051_RDY, RTL8367D_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
                return retVal;

            for(idx = 0; idx < NCTRL_INIT_SIZE; idx++)
            {
                if ((retVal = rtl8367d_setAsicReg(0xE000 + idx, (rtk_uint32)NCtrl_init[idx])) != RT_ERR_OK)
                    return retVal;
            }

            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_DW8051_RDY, RTL8367D_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
                return retVal;

            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_DW8051_RDY, RTL8367D_ACS_IROM_ENABLE_OFFSET, 0)) != RT_ERR_OK)
                return retVal;

            if ((retVal = rtl8367d_setAsicRegBit(RTL8367D_REG_CHIP_RESET, RTL8367D_DW8051_RST_OFFSET, 0)) != RT_ERR_OK)
                return retVal;

            break;
        default:
            break;
    }

    return RT_ERR_OK;
}

/* Function Name:
 *      dal_rtl8367d_switch_portMaxPktLen_set
 * Description:
 *      Set Max packet length
 * Input:
 *      port    - Port ID
 *      speed   - Speed
 *      cfgId   - Configuration ID
 * Output:
 *      None.
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 *      RT_ERR_INPUT        - Error Input
 * Note:
 */
rtk_api_ret_t dal_rtl8367d_switch_portMaxPktLen_set(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 cfgId)
{
    rtk_api_ret_t retVal;

    switch (rtk_switch_chipType_get())
    {
        case CHIP_RTL8367D:
            if ((retVal = _dal_rtl8367d_switch_portMaxPktLen_set(port, speed, cfgId)) != RT_ERR_OK)
                return retVal;
            break;
        case CHIP_RTL8367E:
            return RT_ERR_DRIVER_NOT_FOUND;
        default:
            return RT_ERR_FAILED;
    }
    
    return RT_ERR_OK;
}

/* Function Name:
 *      dal_rtl8367d_switch_portMaxPktLen_get
 * Description:
 *      Get Max packet length
 * Input:
 *      port    - Port ID
 *      speed   - Speed
 * Output:
 *      pCfgId  - Configuration ID
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 *      RT_ERR_INPUT        - Error Input
 * Note:
 */
rtk_api_ret_t dal_rtl8367d_switch_portMaxPktLen_get(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 *pCfgId)
{
    rtk_api_ret_t retVal;

    switch (rtk_switch_chipType_get())
    {
        case CHIP_RTL8367D:
            if ((retVal = _dal_rtl8367d_switch_portMaxPktLen_get(port, speed, pCfgId)) != RT_ERR_OK)
                return retVal;
            break;
        case CHIP_RTL8367E:
            return RT_ERR_DRIVER_NOT_FOUND;
        default:
            return RT_ERR_FAILED;
    }

    return RT_ERR_OK;
}

/* Function Name:
 *      dal_rtl8367d_switch_maxPktLenCfg_set
 * Description:
 *      Set Max packet length configuration
 * Input:
 *      cfgId   - Configuration ID
 *      pktLen  - Max packet length
 * Output:
 *      None.
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 *      RT_ERR_INPUT        - Error Input
 * Note:
 */
rtk_api_ret_t dal_rtl8367d_switch_maxPktLenCfg_set(rtk_uint32 cfgId, rtk_uint32 pktLen)
{
    rtk_api_ret_t retVal;
    
    switch (rtk_switch_chipType_get())
    {
        case CHIP_RTL8367D:
            if ((retVal = _dal_rtl8367d_switch_maxPktLenCfg_set(cfgId, pktLen)) != RT_ERR_OK)
                return retVal;
            break;
        case CHIP_RTL8367E:
            return RT_ERR_DRIVER_NOT_FOUND;
        default:
            return RT_ERR_FAILED;
    }

    return RT_ERR_OK;
}

/* Function Name:
 *      dal_rtl8367d_switch_maxPktLenCfg_get
 * Description:
 *      Get Max packet length configuration
 * Input:
 *      cfgId   - Configuration ID
 *      pPktLen - Max packet length
 * Output:
 *      None.
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 *      RT_ERR_INPUT        - Error Input
 * Note:
 */
rtk_api_ret_t dal_rtl8367d_switch_maxPktLenCfg_get(rtk_uint32 cfgId, rtk_uint32 *pPktLen)
{
    rtk_api_ret_t retVal;
    
    switch (rtk_switch_chipType_get())
    {
        case CHIP_RTL8367D:
            if ((retVal = _dal_rtl8367d_switch_maxPktLenCfg_get(cfgId, pPktLen)) != RT_ERR_OK)
                return retVal;
            break;
        case CHIP_RTL8367E:
            return RT_ERR_DRIVER_NOT_FOUND;
        default:
            return RT_ERR_FAILED;
    }

    return RT_ERR_OK;
}

